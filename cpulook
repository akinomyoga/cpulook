#!/bin/bash

function cpudir.initialize {
  local _scr="$(readlink -f "$0" || /bin/readlink -f "$0" || echo "$0")"
  local _dir="${_scr%/*}"
  [[ $_dir == "$_scr" ]] && _dir=.
  [[ $_dir ]] || _dir=/
  cpudir="$_dir"
}
cpudir.initialize
tmpdir="$HOME/.local/share/cpulook/tmp"
[[ -d $tmpdir ]] || mkdir -p "$tmpdir"

arg_timeout=
arg_host_pattern=
flag_cpugetdata=
flag_help=
function cpulook/read_argument {
  while (($#)); do
    local arg=$1; shift
    case "$arg" in
    (--cpugetdata)
      flag_cpugetdata=1 ;;
    (--help)
      flag_help=1 ;;
    (--host-pattern=*)
      arg_host_pattern=${arg#*=} ;;
    (*)
      if [[ ! $arg_timeout ]]; then
        arg_timeout=$arg
      else
        echo "cpulook (arguments): timeout is specified more than once" >&2
        return 1
      fi ;;
    esac
  done
}

cpulook/read_argument "$@"

if [[ $flag_help ]]; then
  cat <<EOF
cpulook [options] [timeout]

OPTIONS

  --help
    Show help

  --cpugetdata
    Output in the cpugetdata format. For internal usage.

  --host-pattern=HOSTNAMES
    Comma separated list of hostname to check.

TIMEOUT

  Timeout in seconds. Fractional numbers can be specified.

EOF
  exit
fi

#------------------------------------------------------------------------------
# utilities

function get_fileage {
  local var=$1 file=$2
  if [[ -e $file ]]; then
    eval "$var=$(($(date '+%s')-$(date '+%s' -r "$file")))"
  else
    eval "$var=-1"
  fi
}

timeout="${arg_timeout:-10}"
## @var[in] timeout
function wait-until {
  local condcmd="$1"
  local wait_status= it itN
  itN=$(:|awk 'BEGIN{print int('"${timeout:-5}/0.2"')}')
  local spin='|/-\'
  for ((it=0;it<itN;it++)); do
    [[ -t 2 ]] && printf 'waiting %s...%s\r' "${wait_status:+($wait_status) }" "${spin:it%${#spin}:1}" >&2
    sleep 0.2
    "$condcmd" && break
  done
}

#------------------------------------------------------------------------------

function cpustat.view/cpugetdata {
  echo ==cpulook.stat==
  sed 1d
}

function cpustat.view/color {
  if local tput_colors=$(tput colors 2>&1) && ((tput_colors>=256)); then
    local sgr_mine=$'\e[97;48;5;27m';
    local sgr_other=$'\e[48;5;20m';
  else
    local sgr_mine=$'\e[97;42m';
    local sgr_other=$'\e[44m';
  fi

  gawk \
    -v sgr_mine="$sgr_mine" \
    -v sgr_other="$sgr_other" \
    -v COLUMNS="$COLUMNS" '
    function repeat(text,n, _ret){
      _ret="";
      while(n>0){
        if(and(n,1)==1)_ret=_ret text;
        text=text text;
        n=rshift(n,1);
      }
      return _ret;
    }

    function create_progress2(_i,_iW,_iN,_prog,_progress){
      _iN=WIDTH-1;
      for(_i=0;_i<_iN;_i++)_prog[_i]="_";
      for(_i=1;_i<ncor;_i++)_prog[int(WIDTH*_i/ncor-1)]="|";

      # bar: load average (EMA)
      _iW=int(WIDTH*load/ncor+0.5);
      if(_iW<_iN)
        _prog[_iW]="\x1b[91m#\x1b[97m"
      else
        _prog[_iN]="\x1b[91m" repeat("#",1+int(load-ncor+0.5)) "\x1b[m"

      # white: not used
      _iW=int(WIDTH*util/ncor+0.5);
      if(_iW<_iN)_prog[_iW]="\x1b[47m" _prog[_iW]

      # blue: used by other people
      if(uuse<util){
        _iW=int(WIDTH*uuse/ncor+0.5);
        if(_iW<_iN)_prog[_iW]=sgr_other _prog[_iW]
      }

      _progress="";
      for(_i=0;_i<_iN;_i++)_progress=_progress _prog[_i];
      _progress=sgr_mine _progress "\x1b[m";
      if(_prog[_iN]!="")_progress=_progress _prog[_iN];
      return _progress;
    }

    BEGIN{
      WIDTH=COLUMNS-41;
      if(WIDTH>64)WIDTH=64;
    }

    $9=="___"{
      progress="#CPU" repeat("_",WIDTH-5);
      print substr($0,1,length($0)-length($9)) progress;
      next;
    }

    {
      gmax=$2;
      util=$6*0.01;
      load=$7*0.01;
      uuse=$8;
      split($9,data,":");
      ncor=data[1];
      if(ncor+0==0)
        print
      else
        print substr($0,1,length($0)-length($9)) create_progress2();
    }
  '
}

function cpustat.view {
  if [[ $flag_cpugetdata ]]; then
    cpustat.view/cpugetdata
  else
    cpustat.view/color
  fi
}

function cpujobs.view/cpugetdata {
  echo ==cpulook.jobs==
  sed '1d;/^$/d'
}

function cpujobs.view/fold {
  local -i cols=$1
  local s61='                                                             '
  awk -v s61="$s61" -v cols="$cols" '
   BEGIN{
     ioffset=40;
     indent=substr(s61,1,ioffset);
   }

   length($0)<cols{print;next}
   {
     print substr($0,1,cols-1);
     rest=substr($0,cols);
     rlen=length(rest);
     width=cols-1-ioffset;
     if(rlen<width){
       print substr(s61,1,cols-1-rlen) rest;
     }else while(rlen>0){
       print indent substr(rest,1,width);
       rest=substr(rest,width+1);
       rlen=length(rest);}}'
}

function cpujobs.view {
  if [[ $flag_cpugetdata ]]; then
    cpujobs.view/cpugetdata
  elif [[ -t 1 && $COLUMNS ]]; then
    cpujobs.view/fold $((COLUMNS>80?COLUMNS:80))
  else
    cat
  fi
}

#------------------------------------------------------------------------------
# settings

cpustat="$tmpdir/cpustat.txt"
cpujobs="$tmpdir/cpujobs.txt"
cpulist="$cpudir/cpulist.cfg"

function cpulist.load {
  cpulist_data=()
  local line= rex_comment='^[[:space:]]*(#|$)'
  while IFS= read -r line || [[ $line ]]; do
    [[ $line =~ $rex_comment ]] && continue
    cpulist_data[${#cpulist_data[@]}]="$line"
  done < "$cpulist"
}


#------------------------------------------------------------------------------
# base

source "$cpudir/cpudefs.sh"

#------------------------------------------------------------------------------
# cpulook

# show cache
get_fileage age "$cpustat"
if ((0<=age&&age<10)); then
  [[ -s $cpujobs ]] && cpujobs.view < "$cpujobs"
  cpustat.view < "$cpustat"
  exit 0
fi

# load cpulist.cfg
cpulist.load

hosts=()
function hosts.initialize {
  hosts=("${cpulist_data[@]%%[$IFS]*}")

  # filter by arg_host_pattern
  if [[ $arg_host_pattern ]]; then
    IFS=, eval 'local -a patterns=($arg_host_pattern)'
    local -a hosts_filtered=()
    local host pattern
    for host in "${hosts[@]}"; do
      for pattern in "${patterns[@]}"; do
        if [[ $host == $pattern ]]; then
          hosts_filtered[${#hosts_filtered[@]}]=$host
          break
        fi
      done
    done
    hosts=("${hosts_filtered[@]}")
  fi
}
hosts.initialize

ftime="$tmpdir/cpulook.time"
: > "$ftime"

# collect information

function hosts.cpugetdata/check {
  local host count=0 N=${#hosts[@]}
  for host in "${hosts[@]}"; do
    local fstat="$tmpdir/$host.stat"
    [[ -s $fstat && ! ( $fstat -ot $ftime ) ]] && let count++
  done

  wait_status="$count/$N"
  ((count==N))
}

function hosts.cpugetdata {
  [[ -s $cpudir/m/switch/get_used@local.src ]] && \
    source "$cpudir/m/switch/get_used@local.src"

  local line fields host
  for line in "${cpulist_data[@]}"; do
    fields=($line)
    host=${fields[0]}

    : > "$tmpdir/$host.stat"
    rsh.dispatch "$host" "./cpugetdata.sh $line" 2>/dev/null | gawk \
      -v fstat="$tmpdir/$host.stat.part" \
      -v fjobs="$tmpdir/$host.jobs" \
      '
      /^==cpulook\.stat==$/{mode="stat";next;}
      mode=="stat"{print > fstat;}
      /^==cpulook\.jobs==$/{mode="jobs";next;}
      mode=="jobs"{print > fjobs;}
    ' && /bin/mv "$tmpdir/$host.stat.part" "$tmpdir/$host.stat" &>/dev/null &
  done

  wait-until hosts.cpugetdata/check
}

hosts.cpugetdata

# cpujobs
create_cpujobs(){
  local first=1
  local cpu=1
  for cpu in "${hosts[@]}"; do
    local fjobs="$tmpdir/$cpu.jobs"
    if [[ -s $fjobs && ! $fjobs -ot $ftime ]]; then
      if [[ $first ]]; then
        cat "$fjobs"
        first=
      else
        tail -n +2 "$fjobs"
      fi
    fi
  done
  [[ $first ]] || echo
}

# cpustat
create_cpustat(){
  local cpu
  echo "HOST         C  I  NI : UTIL   LOAD   UC ___"
  for cpu in "${hosts[@]}"; do
    if [[ $tmpdir/$cpu.stat -ot $ftime || ! -s $tmpdir/$cpu.stat ]]; then
      printf '%-12s  0  0 -- : ----.- ----.- -- \n' "$cpu"
    else
      echo "$(< "$tmpdir/$cpu.stat")"
    fi
  done
}

if [[ $arg_host_pattern ]]; then
  create_cpujobs | cpujobs.view
  create_cpustat | cpustat.view
else
  create_cpujobs | tee "$cpujobs" | cpujobs.view
  create_cpustat | tee "$cpustat" | cpustat.view
fi
